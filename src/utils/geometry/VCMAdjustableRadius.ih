#include <cstdlib>
#include "shapes/Ball.h"
#include "Statistics.h"

template <typename TSpace, typename TSeparableMetric>
inline
VCMAdjustableRadius<TSpace,TSeparableMetric>::
~VCMAdjustableRadius()
{
  this->clean();
}

template <typename TSpace, typename TSeparableMetric>
inline
VCMAdjustableRadius<TSpace,TSeparableMetric>::
VCMAdjustableRadius( double _R, double _r, Metric aMetric, bool verbose, bool isInDomain )
  : typename Base::Base( _R, _r, aMetric, verbose, isInDomain) {}

template <typename TSpace, typename TSeparableMetric>
inline
VCMAdjustableRadius<TSpace,TSeparableMetric>::
VCMAdjustableRadius( const VCMAdjustableRadius& other )
  : typename Base::Base( other ) {}


template <typename TSpace, typename TSeparableMetric>
inline
VCMAdjustableRadius<TSpace,TSeparableMetric>&
DGtal::VCMAdjustableRadius<TSpace,TSeparableMetric>::
operator=( const VCMAdjustableRadius& other )
{
  Base::operator=( other );
  return *this;
}



template <typename TSpace, typename TSeparableMetric>
template <typename Point2ScalarFunction>
inline
typename VCMAdjustableRadius<TSpace,TSeparableMetric>::MatrixNN
VCMAdjustableRadius<TSpace,TSeparableMetric>::
measure( const typename Point2ScalarFunction& chi_r, const Point& p) const
{
  ASSERT( myProximityStructure != 0 );

  Point b = myProximityStructure->bin( p );
  Ball<Point> ball(p,mySmallR);
  std::vector<Point> neighbors = ball.intersection(myContainer);
  MatrixNN vcm;
  // std::cout << *it << " has " << neighbors.size() << " neighbors." << std::endl;
  for ( typename std::vector<Point>::const_iterator it_neighbors = neighbors.begin(),
          it_neighbors_end = neighbors.end(); it_neighbors != it_neighbors_end; ++it_neighbors )

  {
      Point q = *it_neighbors;
      Scalar coef = chi_r( q - p );
      if ( coef > 0.0 )
        {
          MatrixNN vcm_q = myVCM.at(q);
          vcm_q *= coef;
          vcm += vcm_q;
        }
    }
  return vcm;
}

//-----------------------------------------------------------------------------
template <typename TSpace, typename TSeparableMetric>
template <typename Point2ScalarFunction>
inline
typename VCMAdjustableRadius<TSpace,TSeparableMetric>::MatrixNN
DGtal::VCMAdjustableRadius<TSpace,TSeparableMetric>::
measure( const std::vector<Point>& neighbors, Point2ScalarFunction chi_r, Point p ) const
{
  ASSERT( myProximityStructure != 0 );

  Point b = myProximityStructure->bin( p );

  MatrixNN vcm;
  // std::cout << *it << " has " << neighbors.size() << " neighbors." << std::endl;
  for ( typename std::vector<Point>::const_iterator it_neighbors = neighbors.begin(),
          it_neighbors_end = neighbors.end(); it_neighbors != it_neighbors_end; ++it_neighbors )
    {
      Point q = *it_neighbors;
	   Scalar coef = chi_r( q - p );
      // Scalar coef = 1.0;
      if ( coef > 0.0 )
        {
          typename std::map<Point,MatrixNN>::const_iterator it = myVCM.find( q );
          if ( it != myVCM.end() ) {
			  MatrixNN vcm_q = it->second;
			  vcm_q *= coef;
			  vcm += vcm_q;
		  }
        }
    }
  return vcm;
}


template <typename TSpace, typename TSeparableMetric>
template <typename Point2ScalarFunction>
inline
typename VCMAdjustableRadius<TSpace,TSeparableMetric>::MatrixNN
DGtal::VCMAdjustableRadius<TSpace,TSeparableMetric>::
measureJunction( const Vector& dirVector, Point2ScalarFunction chi_r, Point p ) const
{
  ASSERT( myProximityStructure != 0 );
  typedef DGtal::EigenDecomposition<3,double> LinearAlgebraTool;
  typedef typename TSpace::RealVector Vector;

  Ball<Point> ball(p,mySmallR);
  std::vector<Point> neighbors = ball.pointsInHalfBall(dirVector);

  MatrixNN vcm, evec, null;

  Vector eval;
  std::map<Point, Vector> mapPoint2Normal;
  for ( typename std::vector<Point>::const_iterator it_neighbors = neighbors.begin(),
          it_neighbors_end = neighbors.end(); it_neighbors != it_neighbors_end; ++it_neighbors )
    {
      Point q = *it_neighbors;
      Scalar coef = chi_r( q - p );
      if ( coef > 0.0 )
        {
          typename std::map<Point,MatrixNN>::const_iterator it = myVCM.find( q );
          if ( it != myVCM.end() ) {
			  MatrixNN vcm_q = it->second;
              vcm_q *= coef;
			  vcm += vcm_q;
		  }
        }
    }
  return vcm;
}
