#ifndef VCM_ON_DIGITAL_SURFACE_ADJUSTABLE_RADIUS_H
#define VCM_ON_DIGITAL_SURFACE_ADJUSTABLE_RADIUS_H

#include <iostream>
#include "DGtal/base/Common.h"
#include "DGtal/geometry/surfaces/estimation/VoronoiCovarianceMeasureOnDigitalSurface.h"
#include "DGtal/geometry/volumes/estimation/VoronoiCovarianceMeasure.h"
#include "geometry/VCMAdjustableRadius.h"

template <typename TDigitalSurfaceContainer, typename TSeparableMetric,
		  typename TKernelFunction, typename DTL2>
class VCMOnDigitalSurfaceAdjustableRadius : VoronoiCovarianceMeasureOnDigitalSurface<TDigitalSurfaceContainer, TSeparableMetric, TKernelFunction>
{


	/////////////////////////////////////////////////////////////////////////////
	// template class VoronoiCovarianceMeasureOnDigitalSurface
	/**
	 * Description of template class
	 * 'VoronoiCovarianceMeasureOnDigitalSurface' <p> \brief Aim: This
	 * class specializes the Voronoi covariance measure for digital
	 * surfaces. It adds notably the embedding of surface elements, the
	 * diagonalisation of the VCM, and the orientation of the first VCM
	 * eigenvector toward the interior of the surface.
	 *
	 * @note Documentation in \ref moduleVCM_sec3_1.
	 *
	 * @see VoronoiCovarianceMeasure
	 *
	 * @tparam TDigitalSurfaceContainer the type of digital surface
	 * container (model of CDigitalSurfaceContainer).
	 *
	 * @tparam TSeparableMetric a model of CSeparableMetric used for
	 * computing the Voronoi map (e.g. Euclidean metric is
	 * DGtal::ExactPredicateLpSeparableMetric<TSpace, 2> )
	 *
	 * @tparam TKernelFunction the type of the kernel function chi_r used
	 * for integrating the VCM, a map: Point -> Scalar.
	 */

public:
	typedef TDigitalSurfaceContainer DigitalSurfaceContainer; ///< the chosen container
	typedef TSeparableMetric                         Metric;  ///< the chosen metric
	typedef TKernelFunction                  KernelFunction;  ///< the kernel function
	typedef DigitalSurface<DigitalSurfaceContainer> Surface;  ///< the chosen digital surface
	typedef typename DigitalSurfaceContainer::KSpace KSpace;  ///< the cellular space
	typedef typename DigitalSurfaceContainer::Surfel Surfel;  ///< the n-1 c		lls
	typedef typename KSpace::SCell                    SCell;  ///< the signed cells
	typedef typename KSpace::Space                    Space;  ///< the digital space
	typedef typename KSpace::Point                    Point;  ///< the digital points
	typedef VCMAdjs<Space,Metric>      VCM;  ///< the Voronoi Covariance Measure
	typedef typename VCM::Scalar                     Scalar;  ///< the "real number" type
	typedef typename Surface::ConstIterator   ConstIterator;  ///< the iterator for traversing the surface
	typedef EigenDecomposition<KSpace::dimension,Scalar> LinearAlgebraTool;  ///< diagonalizer (nD).
	typedef typename VCM::VectorN                   VectorN;  ///< n-dimensional R-vector
	typedef typename VCM::MatrixNN                 MatrixNN;  ///< nxn R-matrix
	typedef typename DTL2::Domain DTDomain;

	typedef std::map<Point, double> Point2Radius;
	// ----------------------- Standard services ------------------------------
public:

	/**
	 * Destructor.
	 */
	~VCMOnDigitalSurfaceAdaptableRadius();

	/**
	 * Constructor. Computes the VCM of the given \a surface.
	 *
	 * @param _surface the digital surface that is aliased in this. The
	 * user can \b secure the aliasing by passing a
	 * CountedConstPtrOrConstPtr.
	 *
	 * @param _surfelEmbedding the chosen embedding for surfels.
	 *
	 * @param _R the offset radius for the set of points. Voronoi cells
	 * are intersected with this offset. The unit corresponds to a step in the digital space.
	 *
	 * @param _r (an upper bound of) the radius of the support of the
	 * kernel function \a chi_r (note \f$\chi_r\f$ in the VCM
	 * paper). The unit corresponds to a step in the digital
	 * space. This parameter is used for preparing the data structure
	 * that answers to proximity queries.
	 *
	 * @param chi_r the kernel function whose support has radius less
	 * or equal to \a r.
	 *
	 * @param t the radius for the trivial normal estimator, which is
	 * used for finding the correct orientation inside/outside for the
	 * VCM.
	 *
	 * @param aMetric an instance of the metric.
	 *
	 * @param verbose if 'true' displays information on ongoing computation.
	 */
	VCMOnDigitalSurfaceAdaptableRadius( ConstAlias< Surface > _surface,
										Surfel2PointEmbedding _surfelEmbedding,
										Scalar _R, Scalar _r,
										KernelFunction chi_r, DTL2 dtl2,
										Scalar t = 2.5, Metric aMetric = Metric(),
										bool verbose = false );


	const Point2Radius& mapPoint2Radius() const;

protected:
	Point2Radius myPt2Radius;
	DTL2 myDT;

protected:

	/**
	 * Constructor.
	 * Forbidden by default (protected to avoid g++ warnings).
	 */
	VCMOnDigitalSurfaceAdaptableRadius();

private:

	/**
	 * Copy constructor.
	 * @param other the object to clone.
	 * Forbidden by default.
	 */
	VCMOnDigitalSurfaceAdaptableRadius ( const VCMOnDigitalSurfaceAdaptableRadius & other );

	/**
	 * Assignment.
	 * @param other the object to copy.
	 * @return a reference on 'this'.
	 * Forbidden by default.
	 */
	VCMOnDigitalSurfaceAdaptableRadius & operator= ( const VCMOnDigitalSurfaceAdaptableRadius & other );


};



#endif
